<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="rss.css" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
<title>Michael Skyba</title>
<description>Michael Skyba's RSS Feed</description>
<language>en-us</language>
<link>https://michaelskyba.xyz/rss.xml</link>
<atom:link href="https://michaelskyba.xyz/rss.xml" rel="self" type="application/rss+xml" />

<!-- LB -->

<item>
<title>		Scripture (Updated)</title>
<guid>https://michaelskyba.xyz/blog/5.html#210923102826</guid>
<link>https://michaelskyba.xyz/blog/5.html</link>
<pubDate>Thu, 23 Sep 2021 10:28:35 -0400</pubDate>
<description><![CDATA[File Organization section
]]></description>
</item>


<item>
<title>		Scripture</title>
<guid>https://michaelskyba.xyz/blog/5.html</guid>
<link>https://michaelskyba.xyz/blog/5.html</link>
<pubDate>Wed, 22 Sep 2021 16:16:30 -0400</pubDate>
<description><![CDATA[
		<p>(Written on 2021-09-22)</p>
		<h1>Scripture</h1>
		<p>This article is about <a href="https://github.com/michaelskyba/scripture">scripture</a>,
		an SM-2 implementation that I made. This will not be a rewrite of the README but instead notes
		on why I made it, my workflow with it, etc.</p>
		<h2>SM-2</h2>
		<p>SM-2 is an application of <a href="https://en.wikipedia.org/wiki/Spaced_repetition">spaced repetition</a>.
		The idea is to be able to retain information in your long-term memory while spending as little total time as
		possible reviewing it. SM-2 is a popular algorithm due to it proving to be effective.</p>
		<p>SuperMemo has made many algorithms after SM-2, and I presume that they are even more efficient.
		I don't think there are any non-SuperMemo uses of them, perhaps because they're significantly more complicated
		to implement? Take a look at <a href="https://supermemo.guru/wiki/SuperMemo_Guru">SuperMemo's wiki</a> if you're
		interested in reading about them, or other topics that they seem to have available.</p>
		<h2>Anki</h2>
		<p>Anki is easily the most popular SM-2 implementation, although they slightly tweaked the algorithm. Anki is
		what I have used for a long time before, and all in all, it's a quality piece of software. Anki is infinitely
		better than not using spaced repetition and I have recommended it to many people (in real life) in the past.</p>
		<p>However, Anki has problems, ignorable in many other eyes, but not mine. To cut to the chase, Anki ignores
		the UNIX philosophy. It has a Qt (I think) GUI, a built-in extension manager, built-in synchronization, an
		SQL database, etc. None of these would exist if Anki followed the UNIX philosophy.</p>
		<p>Again, for 99% of people, what I just described is great, and I would not want Anki to actually adopt the ideas
		I have, because it's obviously not their goal.</p>
		<h2>Other CLI Flashcard Programs</h2>
		<p>After I decided that I wanted to stop using Anki, I kept my eye out for any other implementations that I thought
		could be suitable for my use cases. The closest I found was <a href="https://github.com/proycon/vocage">vocage</a>,
		but I didn't end up using it seriously. Vocage does not use any SuperMemo algorithm, from what I understand, so
		my retention rate would significantly decrease from what it was on Anki.</p>
		<p>It wasn't clear to me how to extend it with shell scripts.
		<a href="https://github.com/proycon/vocage/issues/7">This issue</a> might be relevant, but it doesn't seem like it
		will be solved any time soon. I am not familiar with and have no interest in Rust, the language vocage was written in,
		so there's no possibility of me looking through the source code or contributing.</p>
		<p>Around this time, I had the idea of making my own implementation of SM-2. I found out that Wikipedia had a really
		nifty pseudocode description of it on their SuperMemo article that I could base it on, which probably sparked the
		thought.</p>
		<h2>Scripture's Language</h2>
		<p>At the time, my "go-to" programming language was Python (yes), but wanting to become more familiar with
		shell scripting, I decided to write it in sh. In hindsight, this was a great decision. Not only have I gained
		valuable experience in sh, but Python is also the wrong language for this kind of project. I maybe could have used Go,
		which I currently have used for two small CLI projects, but from writing those (with my very limited Go knowledge), I
		think Go would have been more of a hassle.</p>
		<p>I also decided to avoid bashisms, because I wanted greater portability, and also because I wanted to remove bash
		from my computer. Shellcheck says that scripture does not use any bashisms, which is great, but it definitely uses non-POSIX
		flags on certain tools (<code>sed</code> and <code>date</code> are what I can think of off the top of my head). Currently,
		I'm not particularly interested in trying to remove the usage of those flags, because that would be a lot of work.</p>
		<h2>Scripture following the UNIX Philosophy</h2>
		<p>As it stands, I think scripture follows the UNIX philosophy well enough. The SCRIPTURE_HOOK system, I feel, is very
		extensible. I have been able to implement every "personal" feature that I wanted to through its use without polluting
		the main scripture codebase.</p>
		<p>The fact that scripture doesn't have a built-in deck editor is also a huge plus in terms of extensibility. Something
		like creating a new card when you receive an email is trivial to do with scripture but a huge pain with Anki, if that's
		even possible there.</p>
		<p>The main shortcoming is the fact that scripture is interactive. Instead of running commands like
		<code>scripture mark &lt;card&gt; &lt;score&gt;</code>, you only call scripture once on your deck file and then provide
		input through scripture's <code>read &lt; /dev/tty</code> calls.</p>
		<p>From a convenience standpoint, this is totally fine: it works well and is not annoying to type. However, I don't know
		of an easy way to send input into an interactive program like scripture from a separate shell instance. This means that
		something like creating a GUI on top of scripture is going to be more difficult than it needs to be.</p>
		<p>You can say that scripture wouldn't benefit from a GUI, which I would agree with, but that's beside the point.
		Interactivity reduces opportunities. No matter what those are, it's unideal.</p>
		<p>One possible solution is to have the base scripture program take on the model of <code>scripture &lt;command&gt;</code>
		as I mentioned before. Then, the scripture repository would also come with a default interactive wrapper that most people
		would use. The few that want to create an alternative UI would ignore the provided wrapper (which, again, is a separate
		script from the main "scripture" script). This is similar to how sfeed works, with its optional ncurses wrapper.</p>
		<p>If I was smart, I probably would have created this structure from the start. Switching to it now would not be <em>too</em>
		significant of a pivot, considering that scripture has only around 200 total lines of code, but it would still be annoying
		nonetheless, especially since it doesn't provide any current benefit to me. If I happen to need a custom UI in the future,
		or if someone else really needs one, I can implement the more UNIX-y model, but for now, I'm going to leave it the way it is.</p>
		<p>This is also better than the SCRIPTURE_HOOK system because, despite it having good, clear documentation (in my opinion), it's
		still something you have to learn/read about before you can use it. Ideally, simply having shell scripting knowledge should be
		enough.</p>
		<h2>Personal Extensions</h2>
		<h5>Reviewing Cards in Random Order</h5>
		<p>I'm not sure what SM-2's official advice is, but I like reviewing cards in random order. I do not want to impose this opinion
		on every scripture user, so in my hook script, I simply run <code>shuf -o &lt;deck file&gt;</code> before the review starts.</p>
		<h5>Images</h5>
		<p>Image support, of course, is not built into scripture by default. Fortunately, it can be very easily implemented through
		SCRIPTURE_HOOK. See the README on an example implementation. The example deck uses them for pictures of flags, which is
		one of the ways I use them personally.</p>
		<h5>Easy-to-read Text via Imagemagick</h5>
		<p>One of the things I use scripture for is remembering hiragana. However, having normal cards for it is troublesome in two ways.</p>
		<p>First off, to be able to properly each character, I need to have a larger-than-normal font size. So, I would have to increase
		the font size in my terminal every time I have due reviews for my hiragana deck, which is annoying.</p>
		<p>The second and bigger problem is that st, the terminal emulator I use, is having issues with dual-width characters for me. I'm
		pretty sure this is some kind of problem on my end, because <a href="https://st.suckless.org">their homepage</a> lists "wide characters"
		as a supported feature, and I remember them working on a different distribution.</p>
		<p>Anyway, to kill two birds with one stone, I created a script "msk_display" that uses Imagemagick to write text onto a generate imaged,
		then launches sxiv on that temporary image. (<a href="https://gist.github.com/michaelskyba/700366b6649f4dc6fa6cba6c264d3da2">Here</a>
		is the actual script in case you're interested.) In my scripture hook, it will display cards with a "jp:" prefix with msk_display.</p>
		<h5>Spelling Deck</h5>
		<p>Although I "consider" English my native language, there are still some spellings that I occasionally get confused about. To remember
		those, I can use scripture, but what's the right way to do it? I obviously can't have the front of the card "How do you spell 'x'?" because
		that gives away the spelling right there and then.</p>
		<p>One way is to record yourself saying each word so that the front of the card will be an audio file of you speaking and the back will
		be the correct spelling. Here, you would need to use a front_show hook to launch mpv or something on your chosen audio file. I don't like
		this solution because I think it requires too much maintenance, and also because I will quickly get annoyed with hearing my own voice.</p>
		<p>Instead, I decided to use Text-to-Speech (TTS)! My scripture hook looks for "speak:" and runs TTS software to pronounce it. To make sure
		I heard it properly, I have it repeat the word three times, with <code>sleep 1</code> in between repetitions.</p>
		<p>Now, the question of the hour is, of course, "What TTS implementation did you choose?" I went with
		<a href="https://github.com/espeak-ng/espeak-ng">espeak-ng</a>, which I am somewhat satisfied with. The good part of espeak-ng is that its usage
		is simple and convenient. You don't need to have a speech database or machine learning software installed. You don't need to create text or audio
		files (although I'm sure you can if you wanted to). You can simply run <code>espeak-ng "&lt;word&gt;"</code>, and it will play the sound right away.</p>
		<p>That sounds good, but what's wrong, if I'm only "somewhat satisfied"? Well, the speech doesn't sound natural. Inherently, that's not a particularly
		big deal, but the issue is that it can make it hard to determine which word is being spoken. Sometimes, I have to synthesize fake spellings
		(or an entire sentence) to make it easier for me to guess what word I'm being tested on spelling.</p>
		<p>From taking a glance at their GitHub repository, which I looked up so I knew where to link to, it seems like there are quite a lot of options,
		so maybe I can read the documentation later and tweak it to sound more natural to me. Still, if you know of a more easily decipherable engine, let
		me know.</p>
		<p>The last thing I want to note in regards to this spelling deck is a script I made called
		<a href="https://gist.github.com/michaelskyba/a0dacf6f07bcf6b6d4f83015569bae01">"spell_add"</a> (a very creative name). This script makes it more convenient
		to add a new word to the spelling deck. It's another example of something easy to do when your deck files are in plaintext rather than a complicated
		format.</p>
		<h1>Conclusion</h1>
		<p>That's the end of this article. Hopefully, if you read all of it, you have a good idea of whether or not scripture will satisfy your needs. I don't
		think this kind of information belongs in the README, but my website is a fine place to put it.</p>
		<p>I may make another article in a similar style but about <a href="https://github.com/michaelskyba/budgetpass">budgetpass</a>.</p>
		<a href="../blog.html">Blog Index</a>
	
]]></description>
</item>


<item>
<title>		Deltarune Chapter 1 on Linux (Updated)</title>
<guid>https://michaelskyba.xyz/blog/4.html#210917205731</guid>
<link>https://michaelskyba.xyz/blog/4.html</link>
<pubDate>Fri, 17 Sep 2021 20:57:40 -0400</pubDate>
<description><![CDATA[Deltarune released on Steam
]]></description>
</item>


<item>
<title>		Deltarune Chapter 1 on Linux</title>
<guid>https://michaelskyba.xyz/blog/4.html</guid>
<link>https://michaelskyba.xyz/blog/4.html</link>
<pubDate>Fri, 17 Sep 2021 17:28:11 -0400</pubDate>
<description><![CDATA[
		<h1>Deltarune Chapter 1 on Linux</h1>
		<p>With the release of Deltarune Chapter 2 today, I thought I would share how
		I was able to get Chapter 1 working on Linux. I will assume you're running Arch.</p>
		<p>1. Download the .exe from <a href="https://deltarune.com/">Deltarune's website</a></p>
		<p>2. Install Wine and libstrangle</p>
<pre>
ssu pacman -S wine
git clone https://aur.archlinux.org/libstrangle-git.git
cd libstrangle-git
makepkg -sirc</pre> 
		
		<p class="no-margin">3. Install Deltarune as if you were on Windows using Wine:</p>
		<code>wine SURVEY_PROGRAM_WINDOWS_ENGLISH.exe</code>
		<p>For me, it stopped writing new text after a couple of minutes, at which point I killed it with 
C.
		I guess it finishes installing but doesn't quit Wine?</p>
		<p>4. Run Deltarune using strangle:</p>
<pre>
cd "$HOME/.wine/drive_c/Program Files (x86)/SURVEY_PROGRAM"
strangle 30 wine DELTARUNE.exe</pre>
		<p>That's it, it should work now. Using Wine on its own without libstrangle won't work.
		Feel free to try it if you don't believe me.</p>
		<a href="../blog.html">Blog Index</a>
	
]]></description>
</item>


<item>
<title>		Donate</title>
<guid>https://michaelskyba.xyz/donate.html</guid>
<link>https://michaelskyba.xyz/donate.html</link>
<pubDate>Sat, 11 Sep 2021 02:10:05 -0400</pubDate>
<description><![CDATA[
		<h1>Donate</h1>
		<p>Perhaps the existence of this page is a declaration of arrogance, but I genuinely
		believe there's a possibility that something I made could be useful.</p>
		<h2>Bitcoin</h2>
		<img style="margin-bottom: 0;" src="assets/bitcoin.png" alt="bitcoin qr">
		<br>
		<code>bc1qxwvg86dnhkqh9p8z8x6k6rlvvnqx4zfyhxzece</code>
		<h2>Monero</h2>
		<img style="margin-bottom: 0;" src="assets/monero.png" alt="monero qr">
		<br>
		<code>42dPF9eisY3PCyQmLCiSAUEsjVhz2j1gDUixdQKgcXueMEJUNAKTgYG71ekXvvR12MTAyWnqyhfdXjPt3p5ypr3A2vey7RZ</code>
		<br>
		<br>
		<a style="margin-top: 50px;" href="index.html">Home</a>
	
]]></description>
</item>


<item>
<title>		Trying out berry</title>
<guid>https://michaelskyba.xyz/blog/3.html</guid>
<link>https://michaelskyba.xyz/blog/3.html</link>
<pubDate>Sun, 15 Aug 2021 00:29:17 -0400</pubDate>
<description><![CDATA[
		<h1>Trying out berry</h1>
		<h4>Introduction</h4>
		<p>Recently, I found out about <a href="https://github.com/JLErvin/berry">berry</a>,
		which describes itself as "[a] healthy, byte-sized window manager". As of the time I'm writing this,
		I have used berry for around one day. In this post, I would like to share my first impressions.</p>
		<h4>Philosophy</h4>
		<p>The main thing that drew me to berry in the first place is its philosophy.
		<a href="https://dwm.suckless.org">dwm</a>, which I was using before trying berry, does not follow
		the UNIX philosophy as well as I would like. In particular, dwm ships with a statusbar and a hotkey
		daemon (the latter is not a precise description, but I'm not sure what would be a better name;
		if you use dwm, you know what I'm referring to). Neither of these are parts of berry. Additionally,
		berry has no built-in tiling. Instead, you can use berryc to create your own layout.</p>
		<h4>Statusbar</h4>
		<p>If berry doesn't come with its own statusbar, which one did I choose? On dwm, my usage of its
		statusbar consisted of a cron job, running <code>xsetroot -name</code> calls. This was enough for me.
		I didn't need (and still don't need) fancy modules or anything like that.</p>
		<p>With this in mind, I went with the statusbar that berry's website recomended:
		<a href="https://github.com/LemonBoy/bar">lemonbar</a>, which I am quite satisfied with. Lemonbar
		has all of the features I would want in a statusbar without going too far over.</p>
		<p>The main annoyance is that, from what I understand, it is incompatible with fontconfig and
		TTF fonts. After realizing this, I installed
		<a href="https://gitlab.com/protesilaos/lemonbar-xft">lemonbar-xft</a>, a fork with fonts
		working the way I would expect.</p>
		<p>Another thing that caught me a bit off guard was the usage. I assumed you would run <code>bard</code>
		or something similar and then call xsetroot as I was used to. Instead, lemonbar uses standard input.
		For example, you could run <code>echo test | lemonbar -p</code> to set the bar to the word "test".
		Here's what I came up with for replicating my xsetroot workflow:</p>
<pre># Init
rm -f $XDG_DATA_HOME/statusbar
touch $XDG_DATA_HOME/statusbar
tail -f $XDG_DATA_HOME/statusbar | lemonbar -g x25+0+0 -f "Noto Sans JP Medium" -p &</pre>
		<p>Then, inside cron, my battery script runs <code>echo "%{c}$(date)%{c}" >> $XDG_DATA_HOME/statusbar</code>.</p>
		<p>This isn't literally how it works, because I don't just want the date in BusyBox's default format, but you
		get the idea. The <code>%{c}</code>s are used to center the text, which I prefer to dwm's bar, where the placement
		is the right side of the bar. (Yes, I know that there's probably a way to change that, but it's more annoying
		than searching "center" in <code>man lemonbar</code>, especially since dwm's bar additionally shows the title
		of the window and draws workspaces, neither of which I require.)</p>
		<p>Now that I think about it, it's probably easier to simply use <code>killall lemonbar ; echo "%{c}$(date)%{c}" | lemonbar -p</code>.
		I might give that a go later; it will likely perform better over what I just described, the use of a "statusbar" file.</p>
		<h4>berryc</h4>
		<p>Another significant "change" a dwm user would experience is the new reliance on berryc, which is berry's client.</p>
		<p>First, berryc has "settings", which I set in berry's autostart file. I copied the default autostart (from the "examples" directory),
		my main change being that I removed all borders/window decorations.</p>
		<p>Second, and more importantly, berryc gives you control over the management of windows. Instead of setting
		WM-related bindings in a config.h file, you need some kind of hotkey daemon that can map keys to berryc commands.
		I chose to use <a href="https://github.com/baskerville/sxhkd">sxhkd</a>, which I would say is one of my favourite
		projects of all time. sxhkd is such a pleasure to use that I even ported my bindings to
		<a href="https://dwm.suckless.org/patches/fsignal/">fsignal</a> when I was on dwm. As an example,
		<a href="https://gist.github.com/michaelskyba/94d2ba318750cc5e5ab5b76d4ffadc6f">here</a> is my current configuration
		for berry. I have a separate, WM-agnostic configuration that includes everything else (e.g. launching my terminal,
		running dmenu scripts).</p>
		<p>Now, seeing this simple config file, combined with the knowledge that berry has no built-in tiling,
		you may be wondering whether managing windows is a huge pain (compared to dwm). My personal answer is no. So far,
		this basic setup of Super+(h|l|Space) for tiling windows is enough, and I've yet to feel a sudden urge to switch back to dwm.</p>
		<p>You should note that I was not a heavy user of "complicated" tiling on dwm. I mostly had a few windows in master-stack
		mode, occasionally popping into monocle mode. My workflow with berry feels just as convenient. If, however, you are frequently
		using something fancy (<a href="https://dwm.suckless.org/patches/fibonacci/">this, for example</a>), you will need
		to write a few shell scripts to make berry act the way you like. This should be totally possible, though. See their website
		if you're interested in doing so.</p>
		<h4>Caveats</h4>
		<p>In this section, I will describe a few things that I'm unsatisfied with. I'm pretty much nitpicking,
		though, so none of this should be taken very seriously.</p>
		<p>First, neither resizing nor moving windows using (Super|Alt)+Mouse is working for me. This should
		be taken with a mountain of salt, though, because I'm 99% sure that it's my fault. When I first
		tried berry (with the example configuration), it was working fine. I'll fiddle around with it later.</p>
		<p>Second, I'm not a fan of <a href="https://berrywm.org">their website</a>. Its design does not look simple,
		which, from what I can see, sends the opposite message. Some examples of better-designed websites,
		in my opinion, are (the current states of): my website, KISS Linux's website, and OpenBSD's website.</p>
		<p>Even besides the design, some of the information on the website is inaccurate. For instance, on their
		"Usage" page, they wrote <code>window_*_relative</code> instead of <code>window_*_absolute</code>.
		See the man page if something mentioned on their website isn't working the way you would expect.</p>
		<p>Finally, judging from the GitHub issues, I can see that berry's philosophy is not 100% aligned with mine.
		This is to be expected, of course; different people have different opinions, but still. For an example, see
		<a href="https://github.com/JLErvin/berry/issues/127">this issue</a>. In my eyes, this should be left for the user
		to script, which would not be difficult at all. JLErvin doesn't explicitly agree that it should be added,
		but you get what I mean.</p>
		<h4>Conclusion</h4>
		<p>In conclusion, berry is a great window manager that, in my opinion, follows the UNIX philosophy better than
		dwm does. Unless something overwhelmingly negative and completely unexpected comes up, it is unlikely that I
		will switch back to dwm.</p>
		<p>If you don't care about anything else I have said so far, my only advice would be to try
		berry out for yourself. At <em>worst</em>, you'll lose ~20 minutes of your time and garner newfound respect
		for your current window manager.</p>
		<a href="../blog.html">Blog Index</a>
	
]]></description>
</item>


<item>
<title>		msk_music</title>
<guid>https://michaelskyba.xyz/blog/2.html</guid>
<link>https://michaelskyba.xyz/blog/2.html</link>
<pubDate>Fri, 23 Jul 2021 23:22:45 -0400</pubDate>
<description><![CDATA[
		<h1>msk_music</h1>
		<p> I have decided to put this "blog" to use for sharing scripts I write, in
		hopes that one or two of them could be of use to somebody.</p>
		
		<h6><a href="https://gist.github.com/michaelskyba/2e04107265d4255671bb597581afd76a">msk_music</a></h2>
		
		<p>msk_music is a simple and featureless way of listening to music. It uses the
		equivalent of "random" and "consume" modes on mpd (which it aims to replace). For
		my use cases, which I believe are fairly standard, it does so successfully.</p>
		
		<p>Instead of having a vast number of configuration options, additional features
		can be implemented by changing the source code, which, due to being written in
		shell, is completely transparent. For instance,
		<a href="https://gist.github.com/michaelskyba/697a06b1f53f3f8a14e94bd9ccf4de3e">this
		patch</a> will have msk_music only run on .mp4 files.</p>
		
		<p>msk_music depends on mpv and a set of coreutils that support sed's "-i" flag.
		msk_music is around 20 LOC, and was written in about 10 minutes.</p>
		<a href="../blog.html">Blog Index</a>
	
]]></description>
</item>


<item>
<title>		Get a working Wi-Fi connection in an Artix Installation</title>
<guid>https://michaelskyba.xyz/blog/1.html</guid>
<link>https://michaelskyba.xyz/blog/1.html</link>
<pubDate>Tue, 20 Apr 2021 19:38:13 -0400</pubDate>
<description><![CDATA[
		<h1>Get a working Wi-Fi connection in an Artix Installation</h1>
		<p>While Arch and Gentoo have had internet working mostly
		out-of-the-box, Artix has not. I thought it could be beneficial
		if I compiled a list of steps:</p>
		<ol>
			<li>Become root: <code>su</code></li>
			<li>
				Create /etc/wpa_supplicant/wpa_supplicant.conf with the following lines:
				<br>
<pre>
ctrl_interface=/run/wpa_supplicant
update_config=1
</pre>
			</li>
			<li>Make sure rfkill isn't messing things up: <code>rfkill unblock wifi</code></li>
			<li>
				Start wpa_supplicant: <code>wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf</code>
				<br>
				My device name was 'wlan0', but you should edit the command if yours is different.
			</li>
			<li>
				Run wpa_cli.
				<br>
<pre>
wpa_cli
scan
scan_results
add_network
set_network 0 ssid "{the name of your wifi network}"
set_network 0 psk "{the password of your wifi network}"
enable_network 0
save_config
quit
</pre>
			</li>
			<li>Start dhcpcd: <code>dhcpcd</code></li>
		</ol>
		<p>You should be done. I've done two Artix installs and both of them have
		succeeded with this procedure. Note that for both I have used the base-runit
		installation; it's possible that using a different init system (openrc and s6
		are available currently) will require different steps.</p>
		<a href="../blog.html">Blog Index</a>
	
]]></description>
</item>


<item>
<title>		Block a site using /etc/hosts</title>
<guid>https://michaelskyba.xyz/blog/0.html</guid>
<link>https://michaelskyba.xyz/blog/0.html</link>
<pubDate>Tue, 20 Apr 2021 19:15:13 -0400</pubDate>
<description><![CDATA[
		<h1>Block a site using /etc/hosts</h1>
		<p>Simply add <code>0.0.0.0 mysite</code> to your /etc/hosts file.</p>
		
		
		<p>Example: <code>0.0.0.0 facebook.com</code></p>
		
		<p>Here, facebook.com will basically be an alias for '0.0.0.0', which acts as a dummy address.</p>
		
		<a href="https://github.com/StevenBlack/hosts">List of sites you may want to block</a>
		<br>
		<a href="../blog.html">Blog Index</a>
	
]]></description>
</item>


</channel>
</rss>

